############################################################
//                                                        //
// Lembrar de dar git add ao final da edição dos arquivos //
// Anotações da aula passada + essa                       //
//                                                        //
############################################################



Revisao sobre arrays

em array de inteiro, cada numero é 4 bytes (uma palavra), andar o endereço de 4 em 4, para pegar os numeros inteiros
Se eu quiser um array não inicializado, inicio ele em .bss

inteiro é 4 bytes
char é 1 byte --> lw e sw serve para ler e gravar palavras, para caracter usa lb, lbu e sb      \0 é o 00 (para fim de string)
string: .asciiz "gabriel" -> adiciona \0 no final


load byte: lb, rd, imm(rs1) -> indica leitura de um byte na memória, 
load byte unsigned: lbu rd, imm(rs1) -> rd[0:7] é o valor no endereço, o restante vira zero?

memória little-endian e big-endian

no little-endian o endereçamento é feito do maior para o menor (esquerda para a direita, como um numero normal 100 -> cem), no big-endian o *endereçamento* é ao contrario (100 -> hum)


riscv64-linux-gnu-as -march=rv32i -mabi=ilp32 -g strings.s -o strings.o 
riscv64-linux-gnu-ld -m elf32lriscv -static strings.o -o strings.exe
qemu-riscv32-static -g 4444 strings.exe

No outro terminal:

gdb-multiarch strings.exe
target remote :4444
info variable texto
x/7c &texto             --> 0x110a8:        103 'g' 97 'a'  98 'b'  114 'r' 105 'i' 101 'e' 108 'l' #
break end_loop
continue
x/8c &texto                 #conferir, aparentemente a conta para deixar maiusculo está deixando tudo negativo
quit

#######################
Funções

Caller (chamador) função que chama outra função
Callee (chamado) função chamada

Quando um caller(ex: main) chama uma outra funçao(ex: soma(int a, int b)), ambas devem concordar sobre onde os argumentos e valor de retorno devem ser colocados

#####
Caller
passa argumentos para a função por registradores (a0 - a7)
chama usando a instrução jal (salva o valor do endereço seguinte em ra (x1, para endereço de função), e faz o salto para executar as instruções da função chamada)





#####
Callee
lê argumentos passados (em ordem) em (a0 - a7) se precisar de mais argumentos, chama pela pilha
realiza a tarefa e retorna valor no registrador a0
no final volta usando jr ra (endereço dps de onde chamou a função)
Não é bom sobrescrever registradores ou memória usada pelo chamador




jr é jump register


#####
pilha

quem usa a pilha são as Funções, alocada e desalocada dinamicamente por funções, uma área de memória
se uma função chama a outra, ela tem que salvar o ra

registradores preservados e não preservados
callee saved e caller-saved


######## 27 11 25
Lembrar sempre de que quando adicionar na pilha tem que remover tbm
tenho q adicionar na pilha











(gdb) target remote :5556
Remote debugging using :5556
_start () at funcoes.s:12
12          la gp, __global_pointer$
(gdb) break donw
Function "donw" not defined.
Make breakpoint pending on future shared library load? (y or [n]) n
(gdb) break done
Ponto de parada 1 at 0x100c4: file funcoes.s, line 43.
(gdb) continue
Continuing.

Breakpoint 1, done () at funcoes.s:43
43          add t0, t0, zero
(gdb) x/1w &M
0x110dc:        67
(gdb) x/1w &P
0x110e0:        4488
(gdb) 





// Funções com argumento e retorno
uma função não pode interferir no chamador, aquele bagulho de não poder alterar os registradores, ou se for usar, guardar os valores dele na pilha e depois pegar de volta



funções recursivas


riscv64-linux-gnu-as -march=rv32im -mabi=ilp32 -g fatorial.s -o fatorial.o
aluno@lab1-12:~/Documentos/Oc/Organizacao_de_computadores/Aula_5$ riscv64-linux-gnu-ld -m elf32lriscv -static strings.o -o strings.exe
riscv64-linux-gnu-ld: não foi possível localizar strings.o: Arquivo ou diretório inexistente
aluno@lab1-12:~/Documentos/Oc/Organizacao_de_computadores/Aula_5$ riscv64-linux-gnu-ld -m elf32lriscv -static fatorial.o -o fatorial.exe
aluno@lab1-12:~/Documentos/Oc/Organizacao_de_computadores/Aula_5$ qemu-riscv32-static -g 4444 fatorial.exe
qemu-riscv32-static: QEMU: Terminated via GDBstub

outro termila:




aluno@lab1-12:~/Documentos/Oc/Organizacao_de_computadores/Aula_5$ gdb-multiarch fatorial.
exe
GNU gdb (Ubuntu 10.2-0ubuntu1~20.04~1) 10.2
Copyright (C) 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

--Type <RET> for more, q to quit, c to continue without paging--
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from fatorial.exe...
(gdb) target remote :4444
Remote debugging using :4444
_start () at fatorial.s:9
9           li a0, 5 # passa n para fat
(gdb) step
11          jal fat # chama fat passando n=5
(gdb) info register a0
a0             0x5      5
(gdb) step
fat () at fatorial.s:20
20          addi sp, sp, -8 #aloca duas palavras
(gdb) info register a0
a0             0x5      5
(gdb) info register ra
ra             0x1005c  0x1005c <_start+8>
(gdb) step
21          sw a0, 4(sp) #empilha a0
(gdb) step
22          sw ra, 0(sp) #colocando ra no topo (empilha)
(gdb) step
26          addi t1, zero, 1
(gdb) step
27          bgt a0, t1, else
(gdb) step
else () at fatorial.s:33
33          addi a0, a0, -1
(gdb) step
34          jal fat         #retorna em a0
(gdb) info register a0
a0             0x4      4
(gdb) x/w2 sp+4
A syntax error in expression, near `sp+4'.
(gdb) x/2w sp+4
No symbol "sp" in current context.
(gdb) step
fat () at fatorial.s:20
20          addi sp, sp, -8 #aloca duas palavras
(gdb) step
21          sw a0, 4(sp) #empilha a0
(gdb) info register a0
a0             0x4      4
(gdb) info register ra
ra             0x10090  0x10090 <else+8>
(gdb) step
22          sw ra, 0(sp) #colocando ra no topo (empilha)
(gdb) step
26          addi t1, zero, 1
(gdb) step
27          bgt a0, t1, else
(gdb) step
else () at fatorial.s:33
33          addi a0, a0, -1
(gdb) step
34          jal fat         #retorna em a0
(gdb) step
fat () at fatorial.s:20
20          addi sp, sp, -8 #aloca duas palavras
(gdb) step
21          sw a0, 4(sp) #empilha a0
(gdb) info register a0
a0             0x3      3
(gdb) step
22          sw ra, 0(sp) #colocando ra no topo (empilha)
(gdb) step
26          addi t1, zero, 1
(gdb) step
27          bgt a0, t1, else
(gdb) step
else () at fatorial.s:33
33          addi a0, a0, -1
(gdb) step
34          jal fat         #retorna em a0
(gdb) info register a0
a0             0x2      2
(gdb) step
fat () at fatorial.s:20
20          addi sp, sp, -8 #aloca duas palavras
(gdb) info register a0
a0             0x2      2
(gdb) step
21          sw a0, 4(sp) #empilha a0
(gdb) step
22          sw ra, 0(sp) #colocando ra no topo (empilha)
(gdb) step
26          addi t1, zero, 1
(gdb) step
27          bgt a0, t1, else
(gdb) step
else () at fatorial.s:33
33          addi a0, a0, -1
(gdb) step
34          jal fat         #retorna em a0
(gdb) info register a0
a0             0x1      1
(gdb) step
fat () at fatorial.s:20
20          addi sp, sp, -8 #aloca duas palavras
(gdb) step
21          sw a0, 4(sp) #empilha a0
(gdb) step
22          sw ra, 0(sp) #colocando ra no topo (empilha)
(gdb) step
26          addi t1, zero, 1
(gdb) step
27          bgt a0, t1, else
(gdb) step
28          addi sp, sp, 8 #desaloca a pilha
(gdb) step
fat () at fatorial.s:29
29          add a0, zero, 1
(gdb) step
30          jr ra
(gdb) step
else () at fatorial.s:35
35          lw t1, 4(sp)    # pega o a0 (n) empilhado  
(gdb) step
36          lw ra, 4(sp)
(gdb) info register t1
t1             0x2      2
(gdb) step
37          mul a0, t1, a0
(gdb) info register a0
a0             0x1      1
(gdb) step
38          addi sp, sp, 8
(gdb) step
else () at fatorial.s:39
39          jr ra
(gdb) step
0x00000002 in ?? ()
(gdb) info register t1
t1             0x2      2
(gdb) info register a0
a0             0x2      2
(gdb) step
Cannot find bounds of current function
(gdb) step
Cannot find bounds of current function
(gdb) exit
command indefinido: "exit". Tente "help".
(gdb) kill